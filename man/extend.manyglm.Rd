% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extend_manyglm.R
\name{extend.manyglm}
\alias{extend.manyglm}
\title{Produce 'extended' manyglm object with simulated abundances}
\usage{
extend.manyglm(fit, N, coeffs = coef(fit), use.design = TRUE, newdata)
}
\arguments{
\item{fit}{objects of class `manyglm`, typically the result of a call to \link[mvabund]{manyglm}.}

\item{N}{Number of samples for the returned `manyglm` object to be extended.}

\item{coeffs}{Coefficient matrix for a `manyglm` object that characterises the size of effects to be simulated.
See `effect.alt` for help in producing this matrix. Defaults to the coefficient matrix from the inputed `manyglm`
object `coef(fit)`.}

\item{use.design}{Logical. Wether to utilise the design of the inputed `manyglm` object or the design specified by
the data frame `newdata`.}

\item{newdata}{Data frame of same size as the original data frame from the inputed `manyglm` fit, that specifies
a different design of interest.}
}
\description{
`extend.manyglm` returns a manyglm object with `N` observations and simulated response matrix,
that utilises the existing correlation structure of the data.
}
\details{
`extend.manyglm` takes a manyglm object and returns back an 'extended' manyglm object with `N`
observations and a new simulated response matrix. Response abundances are simulated through a Gaussian
copula model that utilises a coefficient matrix `coeff`, the specified `manyglm` model and the joint
correlation structure exhibited between the response variables. To help with the specification of
`coeff`, see `effect.alt` which simplifies this process.

Response variables are simulated through a copula model by first extracting Gaussian copular scores
as Dunn-Smyth residuals, which are obtained from abundances \eqn{y_{ij}} with marginal distributions \eqn{F_j}
which have been specified via the original `manyglm` model `fit`;

\deqn{z_{ij} = \Phi^{-1}{F_{j}(y_{ij}^-) + u_{ij} F_{j}(y_{ij})}}

 These scores then follow a multivariate Gaussian distribution with zero mean and covariance structure \eqn{\Sigma},

 \deqn{z_{ij} ~ N_p(0,\Sigma)}

To avoid estimating a large number \eqn{p(p-1)/2} pairwise correlations within \eqn{\Sigma}, factor analysis is utilised
with one latent factor variable, which can be interpreted as an unobserved environmental covariate.

Thus, in order to simulate new multivariate abundances we simulate new copula scores and back transform them to
abundances as \eqn{y_{ij}= {F^*}_j^{-1}(\Phi(z_{ij}))}, where the inputed coefficient matrix `coeff` specifies the
effect size within the new marginal distributions \eqn{{F^*}_j}.\\

The data frame is also extended in a manner that preserves the original design structure. This is done by first
repeating the design matrix until the number of samples exceeds `N`, then randomly removing rows from the last
repeated data frame until the number of samples equals `N`.

`use.design=False` and `newdata` can be utilised if a different data frame is wanted for simulation.

If users are interested in obtaining simulated multivariate abundances alone from a `manyglm` model, these can be
extracted as the response matrix from the returned `manyglm` object.
}
\examples{
library(mvabund)
data(spider)
spiddat <- mvabund(spider$abund)
X <- data.frame(spider$x)

#Specify 'increasers' and 'decreasers'
increasers <- c("Alopacce","Arctlute" ,"Arctperi","Pardnigr", "Pardpull")
decreasers <- c("Alopcune","Alopfabr" ,"Zoraspin")

#Find power for continuous predictor, N=20 and effect.size=3
glm.spid <- manyglm(spiddat~soil.dry, family="negative.binomial",data=X)
effect.mat <- effect.alt(glm.spid,effect.size=3,pred="soil.dry",increasers,decreasers)
extend.fit <- extend.manyglm(glm.spid,N=10,
                             coeffs=effect.mat) #not needed to be executed for power estimate
powersim.manyglm(glm.spid,N=20,pred="soil.dry",coeffs=effect.mat,cl=makeCluster(1))

#Find power for categorical predictor with 4 levels, N=10, effect.size=1.5
X$Treatment <- rep(c("A","B","C","D"),each=7)
glm.spid <- manyglm(spiddat~Treatment, family="negative.binomial",data=X)
effect.mat <- effect.alt(glm.spid,effect.size=1.5,pred="Treatment",increasers,decreasers)
extend.fit <- extend.manyglm(glm.spid,N=20,
                             coeffs=effect.mat) #not needed to be executed for power estimate
powersim.manyglm(glm.spid,N=20,pred="Treatment",coeffs=effect.mat,cl=makeCluster(1))

#change effect size parameterisation
effect.mat <- effect.alt(glm.spid,effect.size=1.5,
                         pred="Treatment",increasers,decreasers,
                         K=c(3,1,2),OrderedLevels = FALSE)
powersim.manyglm(glm.spid,N=20,pred="Treatment",
                 coeffs=effect.mat,use.design = FALSE,newdata=X_new,cl=makeCluster(1))

#change sampling design
X_new <- X
X_new$Treatment[6:7] <- c("B","B")
extend.fit <- extend.manyglm(glm.spid,N=20,
                             coeffs=effect.mat,use.design = FALSE,newdata=X_new) #not needed to be executed for power estimate
powersim.manyglm(glm.spid,N=20,pred="Treatment",coeffs=effect.mat,use.design = FALSE,newdata=X_new,cl=makeCluster(1))
}
